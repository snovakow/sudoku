<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title></title>
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<script type="module">
		const body = document.createElement('div');

		body.style.fontFamily = "'Courier New', monospace";

		const generateButton = document.createElement('button');
		generateButton.appendChild(document.createTextNode("Generate"));
		generateButton.style.top = '8px';
		generateButton.style.right = '8px';
		generateButton.style.position = 'absolute';
		generateButton.style.height = '32px';

		const loadButton = document.createElement('button');
		loadButton.appendChild(document.createTextNode("Load"));
		loadButton.style.top = '48px';
		loadButton.style.right = '8px';
		loadButton.style.position = 'absolute';
		loadButton.style.height = '32px';

		const dataStore = [];
		const writeData = (count) => {
			const link = document.createElement("a");
			const file = new Blob([dataStore.join('\n')], { type: 'text/plain' });
			link.href = URL.createObjectURL(file);
			link.download = `sudokus${count}.txt`;
			link.click();
			URL.revokeObjectURL(link.href);
			dataStore.length = 0;
		};

		let worker = null;
		const process = (fromFile) => {
			if (worker) {
				worker.terminate();
				worker = null;
			} else {
				const setMessage = (message) => {
					while (body.firstChild) body.removeChild(body.lastChild);
					for (const line of message) {
						const stat = document.createElement('div');
						stat.appendChild(document.createTextNode(line));
						body.appendChild(stat);
					}
				};

				if (fromFile) {
					const lists = [];
					const datas = [];
					let dataIndex = 1;
					let dataCount = 0;
					const fetchCascade = () => {
						const list = `./puzzles2/sudokus${dataIndex}00000.txt`;
						fetch(list).then(response => {
							if (response.status === 404) throw new Error("End of list.", { dataIndex });

							if (response.status !== 200) return;

							response.text().then((data) => {
								datas.push(data);
								dataIndex++;
								fetchCascade();
							});
						}).catch(() => {
							if (datas.length === 0) return;

							worker = new Worker("worker.js", { type: "module" });
							worker.postMessage({
								search: window.location.search,
								puzzles: datas.join('\n'),
							});
							worker.onmessage = (e) => {
								const data = e.data;
								if (data.message) setMessage(data.message);
							};
						});
					}
					fetchCascade();
				} else {
					worker = new Worker("worker.js", { type: "module" });
					worker.postMessage({ search: window.location.search });
					worker.onmessage = (e) => {
						const data = e.data;
						dataStore.push(data.puzzle);
						if (data.totalPuzzles % 100000 === 0) {
							writeData(data.totalPuzzles);
						}

						if (data.message) setMessage(data.message);
					};
				}
			}
		};

		generateButton.addEventListener('click', () => {
			process(false);
		});
		loadButton.addEventListener('click', () => {
			process(true);
		});
		document.body.appendChild(loadButton);
		document.body.appendChild(generateButton);

		document.body.appendChild(body);
	</script>

</head>

<body></body>

</html>